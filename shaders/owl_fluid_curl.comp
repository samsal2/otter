#version 450

/* this is set per dispatch invocation depending on the source dimensions */
layout(push_constant) uniform CONSTANTS { vec2 texel_size; }
constants;

/* velocity */
layout(set = 1, binding = 0, rgba32f) uniform readonly image2D source0;
/* source */
layout(set = 2, binding = 0, rgba32f) uniform readonly image2D source1;
layout(set = 3, binding = 0, rgba32f) uniform writeonly image2D destination0;

#define bilerp(image, uv, texel_size, result)                                 \
  do {                                                                        \
    vec2 st_ = uv / texel_size - 0.5;                                         \
    ivec2 iuv_ = ivec2(floor(st_));                                           \
    vec2 fuv_ = fract(st_);                                                   \
    vec4 a_ = imageLoad(image, (iuv_ + ivec2(0, 0)));                         \
    vec4 b_ = imageLoad(image, (iuv_ + ivec2(1, 0)));                         \
    vec4 c_ = imageLoad(image, (iuv_ + ivec2(0, 1)));                         \
    vec4 d_ = imageLoad(image, (iuv_ + ivec2(1, 1)));                         \
    result = mix(mix(a_, b_, fuv_.x), mix(c_, d_, fuv_.x), fuv_.y);           \
  } while (false)

void main() {
  ivec2 uv_world;
  uv_world.x = int(gl_GlobalInvocationID.x + 1);
  uv_world.y = int(gl_GlobalInvocationID.y + 1);

  ivec2 vl = ivec2(uv_world.x - 1, uv_world.y);
  ivec2 vr = ivec2(uv_world.x + 1, uv_world.y);
  ivec2 vt = ivec2(uv_world.x, uv_world.y - 1);
  ivec2 vb = ivec2(uv_world.x, uv_world.y + 1);

  vec2 uv_norm = uv_world * constants.texel_size;

  float l = imageLoad(source0, vl).y;
  float r = imageLoad(source0, vr).y;
  float t = imageLoad(source0, vt).x;
  float b = imageLoad(source0, vb).x;

  float vorticity = r - l - t + b;

  imageStore(destination0, uv_world, vec4(0.5 * vorticity, 0.0, 0.0, 1.0));
}
